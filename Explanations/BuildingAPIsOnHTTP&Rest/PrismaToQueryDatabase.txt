Integrate a Prisma Client into our app and use it to query database

In order to use Prisma client we first need to import it
so lets go in app.ts and let's do it
we can chek if it is in our p.json as a dependency

so we now want to creat a new instance of prisma client so
let's initialize a variable called prisma and usin new keyword let's say

new Prisma Client

that gives us a prisma client wchich allows us now to go and querying against database

so we will replace the handler that we have created

`
 response.json([
        {
            name: "Mercury",
        },

        {
            name: "Venus",
        }]
    );
`

SO IT GETS RECORDS FROM OUR DATABASE

so let's initialise planets variable equal to awaiting planets from prisma,
with dot notation, so

const planets = await prisma.planet.findMany()

the prisma client has types that are generated when we add models
that means that it updates and we get all this kind of rich type hinting and type checking
adding findMany() which is a method that pullback more than one record, so all the planet that we have

then we're going to send back that planet there shpuld
be an array of planets that is send back as a response body
asking to be formatted as json

using await gets an error because it needs to be inside of
an async function,
so let's make it async by adding before the parameters in the app.get function callback

so now we can save, open postman and make a test request to it

creating a new collection 
in this case Pace Facts API 
save that 
now we can close it and add a request on the left sidebar 
Let us set GET as method request, getting the /planets root qwhich is just the name, 
so we need to put the full url in the placeholder right to the GET method setter 
we can save and then go to our terminal, let the server run with npm run dev 

send the request, seeing the response down to the postman app, giving us a empty array 
that is because at the moment we have got no planets record in ur database 
we need to go add them 

so split the terminal 

and type into the terminal 

npx prisma studio

the prisma studio comes bundled with the prisma cli and if we press enter 
it opens up in our browser showing us the models that we have available, we configured with prisma 
so we got our planet model 
clicking on that we can go ahead and add a couple of planets as test records so that we can see that coming back in postman 

now we can click on Add record
and add a new planet in prsima studio with text numbers, 
press enter and save changes 

as we set before there are the functions updateAt and CreatedAt that are automated, and id too is automatically generated by postgres that record to it
we can add another record 

 as now we have two planet record if we go back to postman making a new request for our get /planets root
 we can now see a response coming back 
 which is an array of planets objects 

 Resume: we managed to get everything wired up in app.ts 
 that when we call /planets in the app.get method it uses 
 prismaclient to make a request to our database and to pull that all back 

 Let's CHEK IF OUR TEST IS STILL WORKING
 we can close the terminal on the right and stop running the other one
 then type in the terminal 

 npm test

 we got a failed here 
 so let's open up our test and taka a look at what we wrote 



  test("GET /planets", async () => {
    const response = await request
        .get("./planets")
        .expect(200)
        .expect("Content-Type", /application\/json/);
       
        expect(response.body).toEqual([
    {
        name: "Mercury",
    },
    {
        name: "Venus",
    },


    this test is expecting a response body to equal to 


 {
        name: "Mercury",
    },
    {
        name: "Venus",
    }


    if we look now in postmanwe sending back smth completely
    different: 
    a full objcet with different datas about planets 
    so we need to update our test to reflect that  
    but when we update it we do not want our app to be talking directly 
    to the database,
    so this code 
    
app.get("/planets", async (request, response) => {
   
    const planets = await prisma.planet.findMany();

    response.json(planets);

    where it is using the prismaclient to make a query against our db 

    we dont want that to rely on a real db 
    because we cant rely on the db to be consistent as we're testing 
    our application and making manual tests with the postmann 
    we might go and changing around the data so we want our test to wokr 
    regardless of what data is in our database

    that means we need to go and mock for the particular 
    client in our test 

    and here 
    const prisma = new PrismaClient(); 
    we have the prisma client coming in 

    now we are going to SPLIT IT OUT 
    so we can create a new instance client separately 
    and then actually do some mocking of the prisma client in our test 
so we can rely on the data weve got going thorugh when we run our tests 

to split things out we gonna 

CREATE NEW DIRECTORY IN SRC FOLDER lib/prisma 
inside of that a new file client.ts 
so let's move the code from app.ts  where we created a new prisma client

`import { PrismaClient } from "@prisma/client";


const prisma = new PrismaClient(); `


moving and paseing it in client.ts
then we have to make sure we are exporting that prismaclient so

export default prisma; 

then back in app.ts and import it 
now it is splitted anda separeted from app.ts 
so now that allows us doing some mocking 
in order to do it in a type safe way 
we need to install the 
jest mock extended package
that allows us to do type safe mocking extentions with jest so if we
type it in our terminal we have to install it as a devdep so 

npm i --save-dev jest-mock-extended 

while it is installing we're going to create an another file inside the folder we created before called
client.mock.ts
this is where we are goin to mock the prisma client 

A MOCK IS A FAKE VERSION OF AN OBKECT OR A CLASS, IN THIS CASE THE PRISMA CLIENT 
so this is what we will be using in oir seerver test to mae sure we are not making queries to the db
so if we go to 
www.prisma.io/docs/guides/testing/unit-testing
we can see documentation and copy what we need like

import { PrismaClient } from '@prisma/client'
import { mockDeep, mockReset, DeepMockProxy } from 'jest-mock-extended'

import prisma from './client'

jest.mock('./client', () => ({
  __esModule: true,
  default: mockDeep<PrismaClient>(),
}))

beforeEach(() => {
  mockReset(prismaMock)
})

export const prismaMock = prisma as unknown as DeepMockProxy<PrismaClient>

and this is what we're going to use, so paste it into client.mock.ts 

we can reformat it to match by clicking ctr + shift + package
letting prettier format it for us
so we got this mock 
`beforeEach(() => {
    mockReset(prismaMock);
});`

and we need to set jest up to use it so let's get in the 
jest.config.ts
adding a couple of new setting 

-clearMock: truethat means after every test that we have running gonna reset the mockReset
it is importatn to make sure we have kind of consistent state between each of our test 

-setupFilesAfterEnv: 
so once jest is done its initial setup we wanted to then load this mock file we've reated 
so rather typing it out we can copy the relative path of client.mok.ts 
adding a ./ before to make sure it starts from the current directory 

now in our test file we're actually goiing to import that mock in our server.test.ts

so we're now pulling in that mock to let jest being configured 

if we head into our test we make sure we can properly test it  

if we adda  const planets variable setting what we expect to come back 
let's actually head to postman, copying the response array objects, we have panets array, that has to be passed into the prisma mock 

so below it we can add in a call to prismaMock.planet.findMany.mockResolvedValue()

then what this means is that when we make any calls whilst we're running our test to that find Many it will send back
this mockValue, passing i the planets array 
ther is a ts error, it is known issue with some of the types 
that come with prisma so let's just say //@ts-ignore up to that declaration
so now we can test 

when we run the test and supertest make the fake request, when the prisma planet findMany() gets called
it's actually going to be calling our mockPlanetFindMany

we will have an error cause we need to update what our test js expects toEqual, obv planets replaces the old objects
if we now go to .env file we can prove we are no calling to the real server 
by temporarly cancel the url path to a empty string 
